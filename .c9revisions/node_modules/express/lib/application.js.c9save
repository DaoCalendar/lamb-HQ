{"ts":1363417838866,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * Module dependencies.\n */\n\nvar connect = require('connect')\n  , Router = require('./router')\n  , methods = require('methods')\n  , middleware = require('./middleware')\n  , debug = require('debug')('express:application')\n  , locals = require('./utils').locals\n  , View = require('./view')\n  , utils = connect.utils\n  , path = require('path')\n  , http = require('http')\n  , join = path.join;\n\n/**\n * Application prototype.\n */\n\nvar app = exports = module.exports = {};\n\n/**\n * Initialize the server.\n *\n *   - setup default configuration\n *   - setup default middleware\n *   - setup route reflection methods\n *\n * @api private\n */\n\napp.init = function(){\n  this.cache = {};\n  this.settings = {};\n  this.engines = {};\n  this.viewCallbacks = [];\n  this.defaultConfiguration();\n};\n\n/**\n * Initialize application configuration.\n *\n * @api private\n */\n\napp.defaultConfiguration = function(){\n  // default settings\n  this.enable('x-powered-by');\n  this.set('env', process.env.NODE_ENV || 'development');\n  debug('booting in %s mode', this.get('env'));\n\n  // implicit middleware\n  this.use(connect.query());\n  this.use(middleware.init(this));\n\n  // inherit protos\n  this.on('mount', function(parent){\n    this.request.__proto__ = parent.request;\n    this.response.__proto__ = parent.response;\n    this.engines.__proto__ = parent.engines;\n  });\n\n  // router\n  this._router = new Router(this);\n  this.routes = this._router.map;\n  this.__defineGetter__('router', function(){\n    this._usedRouter = true;\n    this._router.caseSensitive = this.enabled('case sensitive routing');\n    this._router.strict = this.enabled('strict routing');\n    return this._router.middleware;\n  });\n\n  // setup locals\n  this.locals = locals(this);\n\n  // default locals\n  this.locals.settings = this.settings;\n\n  // default configuration\n  this.set('views', process.cwd() + '/views');\n  this.set('jsonp callback name', 'callback');\n\n  this.configure('development', function(){\n    this.set('json spaces', 2);\n  });\n\n  this.configure('production', function(){\n    this.enable('view cache');\n  });\n};\n\n/**\n * Proxy `connect#use()` to apply settings to\n * mounted applications.\n *\n * @param {String|Function|Server} route\n * @param {Function|Server} fn\n * @return {app} for chaining\n * @api public\n */\n\napp.use = function(route, fn){\n  var app;\n\n  // default route to '/'\n  if ('string' != typeof route) fn = route, route = '/';\n\n  // express app\n  if (fn.handle && fn.set) app = fn;\n\n  // restore .app property on req and res\n  if (app) {\n    app.route = route;\n    fn = function(req, res, next) {\n      var orig = req.app;\n      app.handle(req, res, function(err){\n        req.app = res.app = orig;\n        req.__proto__ = orig.request;\n        res.__proto__ = orig.response;\n        next(err);\n      });\n    };\n  }\n\n  connect.proto.use.call(this, route, fn);\n\n  // mounted an app\n  if (app) {\n    app.parent = this;\n    app.emit('mount', this);\n  }\n\n  return this;\n};\n\n/**\n * Register the given template engine callback `fn`\n * as `ext`.\n *\n * By default will `require()` the engine based on the\n * file extension. For example if you try to render\n * a \"foo.jade\" file Express will invoke the following internally:\n *\n *     app.engine('jade', require('jade').__express);\n *\n * For engines that do not provide `.__express` out of the box,\n * or if you wish to \"map\" a different extension to the template engine\n * you may use this method. For example mapping the EJS template engine to\n * \".html\" files:\n *\n *     app.engine('html', require('ejs').renderFile);\n *\n * In this case EJS provides a `.renderFile()` method with\n * the same signature that Express expects: `(path, options, callback)`,\n * though note that it aliases this method as `ejs.__express` internally\n * so if you're using \".ejs\" extensions you dont need to do anything.\n *\n * Some template engines do not follow this convention, the\n * [Consolidate.js](https://github.com/visionmedia/consolidate.js)\n * library was created to map all of node's popular template\n * engines to follow this convention, thus allowing them to\n * work seemlessly within Express.\n *\n * @param {String} ext\n * @param {Function} fn\n * @return {app} for chaining\n * @api public\n */\n\napp.engine = function(ext, fn){\n  if ('function' != typeof fn) throw new Error('callback function required');\n  if ('.' != ext[0]) ext = '.' + ext;\n  this.engines[ext] = fn;\n  return this;\n};\n\n/**\n * Map the given param placeholder `name`(s) to the given callback(s).\n *\n * Parameter mapping is used to provide pre-conditions to routes\n * which use normalized placeholders. For example a _:user_id_ parameter\n * could automatically load a user's information from the database without\n * any additional code,\n *\n * The callback uses the samesignature as middleware, the only differencing\n * being that the value of the placeholder is passed, in this case the _id_\n * of the user. Once the `next()` function is invoked, just like middleware\n * it will continue on to execute the route, or subsequent parameter functions.\n *\n *      app.param('user_id', function(req, res, next, id){\n *        User.find(id, function(err, user){\n *          if (err) {\n *            next(err);\n *          } else if (user) {\n *            req.user = user;\n *            next();\n *          } else {\n *            next(new Error('failed to load user'));\n *          }\n *        });\n *      });\n *\n * @param {String|Array} name\n * @param {Function} fn\n * @return {app} for chaining\n * @api public\n */\n\napp.param = function(name, fn){\n  var self = this\n    , fns = [].slice.call(arguments, 1);\n\n  // array\n  if (Array.isArray(name)) {\n    name.forEach(function(name){\n      fns.forEach(function(fn){\n        self.param(name, fn);\n      });\n    });\n  // param logic\n  } else if ('function' == typeof name) {\n    this._router.param(name);\n  // single\n  } else {\n    if (':' == name[0]) name = name.substr(1);\n    fns.forEach(function(fn){\n      self._router.param(name, fn);\n    });\n  }\n\n  return this;\n};\n\n/**\n * Assign `setting` to `val`, or return `setting`'s value.\n *\n *    app.set('foo', 'bar');\n *    app.get('foo');\n *    // => \"bar\"\n *\n * Mounted servers inherit their parent server's settings.\n *\n * @param {String} setting\n * @param {String} val\n * @return {Server} for chaining\n * @api public\n */\n\napp.set = function(setting, val){\n  if (1 == arguments.length) {\n    if (this.settings.hasOwnProperty(setting)) {\n      return this.settings[setting];\n    } else if (this.parent) {\n      return this.parent.set(setting);\n    }\n  } else {\n    this.settings[setting] = val;\n    return this;\n  }\n};\n\n/**\n * Return the app's absolute pathname\n * based on the parent(s) that have\n * mounted it.\n *\n * For example if the application was\n * mounted as \"/admin\", which itself\n * was mounted as \"/blog\" then the\n * return value would be \"/blog/admin\".\n *\n * @return {String}\n * @api private\n */\n\napp.path = function(){\n  return this.parent\n    ? this.parent.path() + this.route\n    : '';\n};\n\n/**\n * Check if `setting` is enabled (truthy).\n *\n *    app.enabled('foo')\n *    // => false\n *\n *    app.enable('foo')\n *    app.enabled('foo')\n *    // => true\n *\n * @param {String} setting\n * @return {Boolean}\n * @api public\n */\n\napp.enabled = function(setting){\n  return !!this.set(setting);\n};\n\n/**\n * Check if `setting` is disabled.\n *\n *    app.disabled('foo')\n *    // => true\n *\n *    app.enable('foo')\n *    app.disabled('foo')\n *    // => false\n *\n * @param {String} setting\n * @return {Boolean}\n * @api public\n */\n\napp.disabled = function(setting){\n  return !this.set(setting);\n};\n\n/**\n * Enable `setting`.\n *\n * @param {String} setting\n * @return {app} for chaining\n * @api public\n */\n\napp.enable = function(setting){\n  return this.set(setting, true);\n};\n\n/**\n * Disable `setting`.\n *\n * @param {String} setting\n * @return {app} for chaining\n * @api public\n */\n\napp.disable = function(setting){\n  return this.set(setting, false);\n};\n\n/**\n * Configure callback for zero or more envs,\n * when no `env` is specified that callback will\n * be invoked for all environments. Any combination\n * can be used multiple times, in any order desired.\n *\n * Examples:\n *\n *    app.configure(function(){\n *      // executed for all envs\n *    });\n *\n *    app.configure('stage', function(){\n *      // executed staging env\n *    });\n *\n *    app.configure('stage', 'production', function(){\n *      // executed for stage and production\n *    });\n *\n * Note:\n *\n *  These callbacks are invoked immediately, and\n *  are effectively sugar for the following:\n *\n *     var env = process.env.NODE_ENV || 'development';\n *\n *      switch (env) {\n *        case 'development':\n *          ...\n *          break;\n *        case 'stage':\n *          ...\n *          break;\n *        case 'production':\n *          ...\n *          break;\n *      }\n *\n * @param {String} env...\n * @param {Function} fn\n * @return {app} for chaining\n * @api public\n */\n\napp.configure = function(env, fn){\n  var envs = 'all'\n    , args = [].slice.call(arguments);\n  fn = args.pop();\n  if (args.length) envs = args;\n  if ('all' == envs || ~envs.indexOf(this.settings.env)) fn.call(this);\n  return this;\n};\n\n/**\n * Delegate `.VERB(...)` calls to `router.VERB(...)`.\n */\n\nmethods.forEach(function(method){\n  app[method] = function(path){\n    if ('get' == method && 1 == arguments.length) return this.set(path);\n\n    // if no router attacked yet, attach the router\n    if (!this._usedRouter) this.use(this.router);\n\n    // setup route\n    this._router[method].apply(this._router, arguments);\n    return this;\n  };\n});\n\n/**\n * Special-cased \"all\" method, applying the given route `path`,\n * middleware, and callback to _every_ HTTP method.\n *\n * @param {String} path\n * @param {Function} ...\n * @return {app} for chaining\n * @api public\n */\n\napp.all = function(path){\n  var args = arguments;\n  methods.forEach(function(method){\n    app[method].apply(this, args);\n  }, this);\n  return this;\n};\n\n// del -> delete alias\n\napp.del = app.delete;\n\n/**\n * Render the given view `name` name with `options`\n * and a callback accepting an error and the\n * rendered template string.\n *\n * Example:\n *\n *    app.render('email', { name: 'Tobi' }, function(err, html){\n *      // ...\n *    })\n *\n * @param {String} name\n * @param {String|Function} options or fn\n * @param {Function} fn\n * @api public\n */\n\napp.render = function(name, options, fn){\n  var opts = {}\n    , cache = this.cache\n    , engines = this.engines\n    , view;\n\n  // support callback function as second arg\n  if ('function' == typeof options) {\n    fn = options, options = {};\n  }\n\n  // merge app.locals\n  utils.merge(opts, this.locals);\n\n  // merge options._locals\n  if (options._locals) utils.merge(opts, options._locals);\n\n  // merge options\n  utils.merge(opts, options);\n\n  // set .cache unless explicitly provided\n  opts.cache = null == opts.cache\n    ? this.enabled('view cache')\n    : opts.cache;\n\n  // primed cache\n  if (opts.cache) view = cache[name];\n\n  // view\n  if (!view) {\n    view = new View(name, {\n      defaultEngine: this.get('view engine'),\n      root: this.get('views'),\n      engines: engines\n    });\n\n    if (!view.path) {\n      var err = new Error('Failed to lookup view \"' + name + '\"');\n      err.view = view;\n      return fn(err);\n    }\n\n    // prime the cache\n    if (opts.cache) cache[name] = view;\n  }\n\n  // render\n  try {\n    view.render(opts, fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Listen for connections.\n *\n * A node `http.Server` is returned, with this\n * application (which is a `Function`) as its\n * callback. If you wish to create both an HTTP\n * and HTTPS server you may do so with the \"http\"\n * and \"https\" modules as shown here:\n *\n *    var http = require('http')\n *      , https = require('https')\n *      , express = require('express')\n *      , app = express();\n *\n *    http.createServer(app).listen(80);\n *    https.createServer({ ... }, app).listen(443);\n *\n * @return {http.Server}\n * @api public\n */\n\napp.listen = function(){\n  var server = http.createServer(this);\n  return server.listen.apply(server, arguments);\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":12058}]],"length":12058}
