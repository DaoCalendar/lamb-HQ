{"ts":1363518380274,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * Module dependencies.\n */\n\nvar Route = require('./route')\n  , utils = require('../utils')\n  , methods = require('methods')\n  , debug = require('debug')('express:router')\n  , parse = require('connect').utils.parseUrl;\n\n/**\n * Expose `Router` constructor.\n */\n\nexports = module.exports = Router;\n\n/**\n * Initialize a new `Router` with the given `options`.\n *\n * @param {Object} options\n * @api private\n */\n\nfunction Router(options) {\n  options = options || {};\n  var self = this;\n  this.map = {};\n  this.params = {};\n  this._params = [];\n  this.caseSensitive = options.caseSensitive;\n  this.strict = options.strict;\n  this.middleware = function router(req, res, next){\n    self._dispatch(req, res, next);\n  };\n}\n\n/**\n * Register a param callback `fn` for the given `name`.\n *\n * @param {String|Function} name\n * @param {Function} fn\n * @return {Router} for chaining\n * @api public\n */\n\nRouter.prototype.param = function(name, fn){\n  // param logic\n  if ('function' == typeof name) {\n    this._params.push(name);\n    return;\n  }\n\n  // apply param functions\n  var params = this._params\n    , len = params.length\n    , ret;\n\n  for (var i = 0; i < len; ++i) {\n    if (ret = params[i](name, fn)) {\n      fn = ret;\n    }\n  }\n\n  // ensure we end up with a\n  // middleware function\n  if ('function' != typeof fn) {\n    throw new Error('invalid param() call for ' + name + ', got ' + fn);\n  }\n\n  (this.params[name] = this.params[name] || []).push(fn);\n  return this;\n};\n\n/**\n * Route dispatcher aka the route \"middleware\".\n *\n * @param {IncomingMessage} req\n * @param {ServerResponse} res\n * @param {Function} next\n * @api private\n */\n\nRouter.prototype._dispatch = function(req, res, next){\n  var params = this.params\n    , self = this;\n\n  debug('dispatching %s %s (%s)', req.method, req.url, req.originalUrl);\n\n  // route dispatch\n  (function pass(i, err){\n    var paramCallbacks\n      , paramIndex = 0\n      , paramVal\n      , route\n      , keys\n      , key;\n\n    // match next route\n    function nextRoute(err) {\n      pass(req._route_index + 1, err);\n    }\n\n    // match route\n    req.route = route = self.matchRequest(req, i);\n\n    // no route\n    if (!route) return next(err);\n    debug('matched %s %s', route.method, route.path);\n\n    // we have a route\n    // start at param 0\n    req.params = route.params;\n    keys = route.keys;\n    i = 0;\n\n    // param callbacks\n    function param(err) {\n      paramIndex = 0;\n      key = keys[i++];\n      paramVal = key && req.params[key.name];\n      paramCallbacks = key && params[key.name];\n\n      try {\n        if ('route' == err) {\n          nextRoute();\n        } else if (err) {\n          i = 0;\n          callbacks(err);\n        } else if (paramCallbacks && undefined !== paramVal) {\n          paramCallback();\n        } else if (key) {\n          param();\n        } else {\n          i = 0;\n          callbacks();\n        }\n      } catch (err) {\n        param(err);\n      }\n    };\n\n    param(err);\n\n    // single param callbacks\n    function paramCallback(err) {\n      var fn = paramCallbacks[paramIndex++];\n      if (err || !fn) return param(err);\n      fn(req, res, paramCallback, paramVal, key.name);\n    }\n\n    // invoke route callbacks\n    function callbacks(err) {\n      var fn = route.callbacks[i++];\n      try {\n        if ('route' == err) {\n          nextRoute();\n        } else if (err && fn) {\n          if (fn.length < 4) return callbacks(err);\n          fn(err, req, res, callbacks);\n        } else if (fn) {\n          if (fn.length < 4) return fn(req, res, callbacks);\n          callbacks();\n        } else {\n          nextRoute(err);\n        }\n      } catch (err) {\n        callbacks(err);\n      }\n    }\n  })(0);\n};\n\n/**\n * Attempt to match a route for `req`\n * with optional starting index of `i`\n * defaulting to 0.\n *\n * @param {IncomingMessage} req\n * @param {Number} i\n * @return {Route}\n * @api private\n */\n\nRouter.prototype.matchRequest = function(req, i, head){\n  var method = req.method.toLowerCase()\n    , url = parse(req)\n    , path = url.pathname\n    , routes = this.map\n    , i = i || 0\n    , route;\n\n  // HEAD support\n  if (!head && 'head' == method) {\n    route = this.matchRequest(req, i, true);\n    if (route) return route;\n     method = 'get';\n  }\n\n  // routes for this method\n  if (routes = routes[method]) {\n\n    // matching routes\n    for (var len = routes.length; i < len; ++i) {\n      route = routes[i];\n      if (route.match(path)) {\n        req._route_index = i;\n        return route;\n      }\n    }\n  }\n};\n\n/**\n * Attempt to match a route for `method`\n * and `url` with optional starting\n * index of `i` defaulting to 0.\n *\n * @param {String} method\n * @param {String} url\n * @param {Number} i\n * @return {Route}\n * @api private\n */\n\nRouter.prototype.match = function(method, url, i, head){\n  var req = { method: method, url: url };\n  return  this.matchRequest(req, i, head);\n};\n\n/**\n * Route `method`, `path`, and one or more callbacks.\n *\n * @param {String} method\n * @param {String} path\n * @param {Function} callback...\n * @return {Router} for chaining\n * @api private\n */\n\nRouter.prototype.route = function(method, path, callbacks){\n  var method = method.toLowerCase()\n    , callbacks = utils.flatten([].slice.call(arguments, 2));\n\n  // ensure path was given\n  if (!path) throw new Error('Router#' + method + '() requires a path');\n\n  // ensure all callbacks are functions\n  callbacks.forEach(function(fn, i){\n    if ('function' == typeof fn) return;\n    var type = {}.toString.call(fn);\n    var msg = '.' + method + '() requires callback functions but got a ' + type;\n    throw new Error(msg);\n  });\n\n  // create the route\n  debug('defined %s %s', method, path);\n  var route = new Route(method, path, callbacks, {\n    sensitive: this.caseSensitive,\n    strict: this.strict\n  });\n\n  // add it\n  (this.map[method] = this.map[method] || []).push(route);\n  return this;\n};\n\nmethods.forEach(function(method){\n  Router.prototype[method] = function(path){\n    var args = [method].concat([].slice.call(arguments));\n    this.route.apply(this, args);\n    return this;\n  };\n});\n"]],"start1":0,"start2":0,"length1":0,"length2":6060}]],"length":6060}
